---
title: High quality GIF from video
tags: shell, ffmpeg, utils
---

#+BEGIN_EXPORT html
<div class="post-image post-image--split">
<img src="/images/gifify-quality-0.gif" />
<img src="/images/gifify-quality-1.gif" />
</div>
#+END_EXPORT

When it comes to converting video to GIF, one usually gets a huge file and a
terrible quality. Most of the guides use FFmpeg to do the conversion, but in
some cases result might annoy you. And as it turns out, folks from FFmpeg made
[[http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html][huge steps]] in improving the GIF output.

#+BEGIN_QUOTE
As you probably know, GIF is limited to a palette of 256 colors. And by default,
FFmpeg just uses a generic palette that tries to cover the whole color space in
order to support the largest variety of content:
#+END_QUOTE

#+BEGIN_EXPORT html
<div class="post-image">
<img src="/images/ffmpeg-default-palette.png" />
</div>
#+END_EXPORT

The idea is to generate a custom palette and use it during conversion.

#+BEGIN_SRC bash
  # generate a palette
  $ ffmpeg -i input.mov -vf "scale=320:-1:flags=lanczos,palettegen palette.png"

  # output the GIF using generated palette
  $ ffmpeg -i input.mov -i palette.png -filter_complex "scale=320:-1:flags=lanczos[x];[x][1:v]paletteuse" output.gif
#+END_SRC

Since I am not good at remembering this kind of commands (and I hate to cycle
the history of commands), I've created a simple script for doing exactly this.
It's called =gifify= and you can find it in my [[https://github.com/d12frosted/environment/blob/master/utils/bin/gifify][.environment]] repository.

#+BEGIN_SRC bash
  $ gifify -i file.mov # output is file.gif
#+END_SRC

Strong points of this script:

1. You can pass scaling to =ffmpeg= (usually I don't want to mess with the
   actual size).
   #+BEGIN_SRC bash
     $ gifify -i file.mov -s 0.5
   #+END_SRC
2. You can pass any additional arguments to =ffmpeg= (like time).
   #+BEGIN_SRC bash
     $ gifify -i file.mov -t 26
   #+END_SRC

For curious ones, here is the current version of the script:

#+BEGIN_SRC bash
  #!/usr/bin/env bash

  set -e

  POSITIONAL=()
  SCALE=1

  while [[ $# -gt 0 ]]
  do
    key="$1"

    case $key in
      -i|--input)
        INPUT="$2"
        shift # past argument
        shift # past value
        ;;
      -s|--scale)
        SCALE="$2"
        shift # past argument
        shift # past value
        ;;
      ,*)    # unknown option
        POSITIONAL+=("$1") # save it in an array for later
        shift # past argument
        ;;
    esac
  done
  set -- "${POSITIONAL[@]}" # restore positional parameters

  OUTPUT="${INPUT%.*}.gif"
  PALETTE="${INPUT%.*}.png"

  echo "input  = ${INPUT}"
  echo "output = ${OUTPUT}"
  echo "scale  = ${SCALE}"
  echo "args   = ${POSITIONAL[*]}"

  function cleanup () {
    rm -f "$PALETTE"
  }

  trap cleanup INT TERM EXIT

  ffmpeg ${POSITIONAL[*]} \
         -i "$INPUT" \
         -vf "scale=iw*${SCALE}:ih*${SCALE}:flags=lanczos,palettegen" \
         "$PALETTE"

  ffmpeg ${POSITIONAL[*]} \
         -i "$INPUT" \
         -i "$PALETTE" \
         -filter_complex "scale=iw*${SCALE}:ih*${SCALE}:flags=lanczos[x];[x][1:v]paletteuse" \
         "$OUTPUT"

  cleanup
#+END_SRC

* More quality

In this post, I covered only quality improvements from using a custom palette.
But actually, there are other ways to tweak you GIF when using FFmpeg. You can
find out more in [[http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html][High quality GIF with FFmpeg]].

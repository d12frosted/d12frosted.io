---
title: "Towards future-safe emacs.d"
tags: emacs
description: "Boosting emacs.d development flow"
publish: false
---

*TL;DR* This post describes an approach to make byte compiler and various
linters happy and *useful* in your =.emacs.d=, while maintaining startup
performance, ability to write embedded packages and test them. This is going to
be a long post, so grab a bottle of wine, snacks and follow me. In case you lack
these things, just take a look at [[https://d12frosted.io/posts/2021-03-13-emacs-d.html#solution][results]].

#+begin_export html
<hr/>
#+end_export

The longest project in my life is [[https://github.com/d12frosted/environment][environment]], it started with [[https://github.com/d12frosted/environment/tree/master/emacs][Emacs
configurations]] - personal frustration and my biggest time +waster+ investment. I
might be masochistic, but I never felt sorry for falling into this +trap+ world.
And boy, sometimes it is painful to maintain something in this ever mutating and
mutable dynamic system.

There are various tools to help maintaining Emacs package, all fall into one of
four categories - project management tools (e.g. [[https://cask.readthedocs.io/en/latest/][Cask]], [[https://github.com/doublep/eldev/][Eldev]], [[https://github.com/alphapapa/makem.sh][makem.sh]]),
compiler (e.g. built-in byte compiler), linters (e.g. [[https://github.com/purcell/package-lint][package-lint]], [[https://github.com/mattiase/relint][relint]],
[[https://github.com/gonewest818/elisp-lint/][elisp-lint]], [[https://github.com/emacs-elsa/Elsa][Elsa]]) and test frameworks (e.g. [[https://www.gnu.org/software/emacs/manual/html_node/ert/index.html][ERT]], [[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]]). The tricky part
comes when you want to use them for maintaining your own Emacs configurations,
as they have different requirements from regular packages. At least in my case,
they do.

First of all, I want Emacs to start as quickly as possible (e.g. in less than a
second), meaning that I need to use tools like =use-package= for deferred
loading. Meaning, I can't =require= most of the packages directly except those
that are used in the bootstrapping process.

Secondly, I have lots of additional functions extending or combining
functionality of one or more packages. But I hate to define them inside
=use-packge= macro. Aside from aesthetics, I want to retain functionality of
=xref-find-definitions=. But having definitions outside of =use-package= means
that I will get many false byte compiler warnings and errors. Which is not
helpful!

Thirdly, bootstrap process is different as project management tools isolate your
package development from your Emacs configurations, which makes sense in
general, but doesn't make sense when you develop the aforementioned
configurations.

The closest approach I know about is [[https://github.com/hlissner/doom-emacs][doom-emacs]], but even there =.emacs.d= is
[[https://github.com/hlissner/doom-emacs/blob/46dedb3e3361535052d199e994b641dca2c2cffd/modules/lang/emacs-lisp/config.el#L14][ignored]]. Let me just quote a docstring from there:

#+begin_quote
This checker (flycheck) tends to produce a lot of false positives in your
.emacs.d and private config, so it is mostly useless there. However, special
hacks are employed so that flycheck still does *some* helpful linting.
#+end_quote

But it's Emacs, right? Everything is possible! So let's find a way to make byte
compiler and linters helpful and enable testing of Emacs configurations.

#+BEGIN_EXPORT html
<div class="post-image post-image-split">
<img src="/images/emacs-d-1.png" /><img src="/images/emacs-d-2.png" />
</div>
#+END_EXPORT

#+BEGIN_HTML
<!--more-->
#+END_HTML

* Table of Contents :TOC_3:
- [[#solution][Solution]]
  - [[#content-of-early-init][Content of =early-init=]]
  - [[#content-of-initel][Content of =init.el=]]
    - [[#add-lisp-directory-to-load-path][Add =lisp= directory to =load-path=]]
    - [[#garbage-collection-thresholds][Garbage collection thresholds]]
    - [[#bootstrap][Bootstrap]]
    - [[#setup-custom-file-location][Setup =custom-file= location]]
    - [[#loading-autoloads][Loading autoloads]]
    - [[#loading-other-init-files][Loading other init files]]
    - [[#loading-custom-file][Loading =custom-file=]]
  - [[#content-of-init-elpa][Content of =init-elpa=]]
    - [[#bootstrap-straightel][Bootstrap =straight.el=]]
    - [[#setup-use-package][Setup =use-package=]]
    - [[#popular-packages][Popular packages]]
  - [[#content-of-eldev][Content of Eldev]]
    - [[#specify-project-files][Specify project files]]
    - [[#use-melpa][Use MELPA]]
    - [[#define-bootstrap-command][Define bootstrap command]]
    - [[#define-upgrade-command][Define upgrade command]]
    - [[#define-autoloads-plugin][Define autoloads plugin]]
    - [[#linting-configuration][Linting configuration]]
  - [[#content-of-makefile][Content of Makefile]]
  - [[#autoloads][autoloads]]
  - [[#linting][Linting]]
  - [[#testing][Testing]]
  - [[#eru][eru]]
- [[#build-tool][Build tool]]
- [[#package-management-tool][Package management tool]]
- [[#package-configuration-tool][Package configuration tool]]
- [[#linter][Linter]]
- [[#testing-framework][Testing framework]]
- [[#whats-next][What's next]]

* Solution

Before we dive into too much details, let me describe the solution from higher
level.

- [[https://github.com/doublep/eldev/][doublep/eldev]] is a [[#build-tool][build tool]] because it's powerful and extensible.
- [[https://github.com/raxod502/straight][raxod502/straight]] is a [[#package-management-tool][package management tool]] because it's consistent and
  reliable.
- [[https://github.com/jwiegley/use-package][jwiegley/use-package]] is a [[#package-configuration-tool][package configuration tool]] because it's easy to use
  and widely adopted.
- [[https://github.com/gonewest818/elisp-lint/][gonewest818/elisp-lint]] is a [[#linter][linter]] because it aggregates many other linters.
- [[https://github.com/jorgenschaefer/emacs-buttercup][jorgenschaefer/emacs-buttercup]] is a [[#testing-framework][testing framework]] because it's easy to
  use.

The structure of my =.emacs.d= looks like this:

#+begin_example
  .
  ├── Eldev
  ├── Makefile
  ├── README.org
  ├── early-init.el
  ├── init.el
  ├── lisp
  │   ├── config-aaa.el
  │   ├── config-bbb.el
  │   ├── ...
  │   ├── config-zzz.el
  │   ├── init-autoloads.el
  │   ├── init-elpa.el
  │   ├── init-aaa.el
  │   ├── init-bbb.el
  │   ├── ...
  │   ├── init-zzz.el
  │   ├── lib-aaa.el
  │   ├── lib-bbb.el
  │   ├── ...
  │   ├── lib-zzz.el
  ├── templates
  │   ├── emacs-lisp-mode
  │   │   ├── template_1
  │   │   ├── ...
  │   │   └── template_n
  │   └── haskell-mode
  │       ├── template_1
  │       ├── ...
  │       └── template_n
  ├── test
  │   ├── lib-aaa-test.el
  │   ├── lib-bbb-test.el
  │   ├── ...
  └── └── lib-zzz-test.el
#+end_example

As you can see, all lisp files are located inside of =lisp= directory (you
should not put them on the same level as =init.el= file as that directory can't
be part of =load-path=), and all tests are located inside of =test= directory.

There is a naming convention:

- =init-xxx= is a file lazily initializing =xxx= feature, it can be a
  programming language (e.g. =init-haskell=) or a feature (e.g. =init-project=)
  - this is the only file type describing what packages to install, how to
    initialize and configure them;
  - it is safe to require these files, as they should deferring any loading as
    much as possible;
- =lib-xxx= is a file containing various utilities depending on packages defined
  in =init-xxx= file
  - these files are loaded via [[#autoloads][autoloads]], and they should never be required
    directly;
  - these files can safely =require= any packages defined in =init-xxx= to help
    linter and byte compiler;
  - in some sense, =lib-xxx= are packages that are not distributed via MELPA,
    but rather located in =emacs.d= folder;
  - my various extensions around =org-mode= called =vulpea= are good examples:
    - [[https://github.com/d12frosted/environment/blob/6ffa964e77410b71058c3d1c43a2381a90bbc6aa][lib-vulpea-agenda.el]]
    - [[https://github.com/d12frosted/environment/blob/6ffa964e77410b71058c3d1c43a2381a90bbc6aa/emacs/lisp/lib-vulpea-capture.el][lib-vulpea-capture.el]]
    - [[https://github.com/d12frosted/environment/blob/6ffa964e77410b71058c3d1c43a2381a90bbc6aa/emacs/lisp/lib-vulpea-refile.el][lib-vulpea-refile.el]]
    - [[https://github.com/d12frosted/environment/blob/6ffa964e77410b71058c3d1c43a2381a90bbc6aa/emacs/lisp/lib-vulpea-id.el][lib-vulpea-id.el]]
    - [[https://github.com/d12frosted/environment/blob/6ffa964e77410b71058c3d1c43a2381a90bbc6aa/emacs/lisp/lib-vulpea.el][lib-vulpea.el]]
- =config-xxx= is a file containing variables and constants required by both
  =init-xxx= and =lib-xxx= files, allowing to avoid circular dependencies;
  - as they do not load any packages, it is safe to require this file from any
    other file;

The only exception is =init-autoloads.el= file containing [[#autoloads][autoloads]].

** Content of =early-init=

See [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][relevant section]] in Emacs Help for more information on The Early Init File,
introduced in Emacs 27.1. Basically, this file is great for frame
customizations. In my case I love to disable as much clutter as possible:

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(tool-bar-lines . 0))
  (add-to-list 'default-frame-alist '(menu-bar-lines . 0))
  (add-to-list 'default-frame-alist '(vertical-scroll-bars))
#+end_src

This file is totally optional, you can safely omit it in your setup. But if you
have any frame customization, putting them in =early-init= file might speed up
your Emacs and fix some visual clutter upon startup.

** Content of =init.el=

The goal of this file is to =require= all =init-xxx= files. The structure is
trivial:

1. Add =lisp= folder to =load-path=, so we can use =require=.
2. Adjust garbage collection thresholds, so things run smoother.
3. Load =config-path= declaring various path constants.
4. Load =init-elpa= which 'bootstraps' your package and configuration management
   tools.
5. Load [[#autoloads][autoloads]] file.
6. Load all other =init-xxx= files.
7. Load =custom-file=, even if you are not using =customize= interface, you
   need this to use =.dir-locals.el=.

*** Add =lisp= directory to =load-path=

#+begin_src emacs-lisp
  ;; Since we might be running in CI or other environments, stick to
  ;; XDG_CONFIG_HOME value if possible.
  (let ((emacs-home (if-let ((xdg (getenv "XDG_CONFIG_HOME")))
                        (expand-file-name "emacs/" xdg)
                      user-emacs-directory)))
    ;; Add Lisp directory to `load-path'.
    (add-to-list 'load-path (expand-file-name "lisp" emacs-home)))
#+end_src

*** Garbage collection thresholds

Garbage collection is a huge contributor to startup time. We temporarily
increase this value to prevent garbage collection from running, then reset it to
some big number in =emacs-startup-hook=. I discovered this trick thanks to
[[https://github.com/hlissner/doom-emacs/][hlissner/doom-emacs]]. But it is widely used by many people, for example
[[https://github.com/purcell/emacs][purcell/emacs]].

In addition it is a good idea to use [[https://github.com/emacsmirror/gcmh][emacsmirror/gcmh]] (aka Garbage Collector
Magic Hack) to improve performance of interactive functions.

#+begin_src emacs-lisp
  ;; Adjust garbage collection thresholds during startup, and thereafter
  (let ((normal-gc-cons-threshold (* 20 1024 1024))
        (init-gc-cons-threshold (* 128 1024 1024)))
    (setq gc-cons-threshold init-gc-cons-threshold)
    (add-hook 'emacs-startup-hook
              (lambda () (setq gc-cons-threshold
                               normal-gc-cons-threshold))))
#+end_src

*** Bootstrap

#+begin_src emacs-lisp
  (require 'config-path)
  (require 'init-elpa)
#+end_src

Literally, that's it. Checkout [[#content-of-init-elpa][content of =init-elpa=]] to find out how it works.

*** Setup =custom-file= location

Before we load anything, we should setup location of our =custom-file=,
otherwise Emacs customization system will pollute our =init.el= file.

#+begin_src emacs-lisp
  (setq custom-file (concat path-local-dir "custom.el"))
#+end_src

The constant =path-local-dir= is defined in =config-path=:

#+begin_src emacs-lisp
  (defconst path-local-dir
    (concat
     (file-name-as-directory
      (or (getenv "XDG_CACHE_HOME")
          (concat path-home-dir ".cache")))
     "emacs/")
    "The root directory for local Emacs files.

  Use this as permanent storage for files that are safe to share
  across systems.")
#+end_src

*** Loading autoloads

#+begin_src emacs-lisp
  ;; load autoloads file
  (unless elpa-bootstrap-p
    (unless (file-exists-p path-autoloads-file)
      (error "Autoloads file doesn't exist, please run '%s'"
             "eru install emacs"))
    (load path-autoloads-file nil 'nomessage))
#+end_src

The most important bit here is the last line, which loads file containing
[[#autoloads][autoloads]] and errors out if it doesn't exist. We want to load this file before
any other modules to make autoloaded functions available there. But of course we
can't load this file during bootstrap process which generates this file.

*** Loading other init files

Now comes the easy part, we just load all =init-xxx= files that we have.

#+begin_src emacs-lisp
  ;; core
  (require 'init-env)
  (require 'init-kbd)
  (require 'init-editor)
  ;; ...

  ;; utilities
  (require 'init-selection)
  (require 'init-project)
  (require 'init-vcs)
  (require 'init-ide)
  (require 'init-vulpea)
  (require 'init-vino)
  (require 'init-pdf)
  ;; ...

  ;; languages
  (require 'init-elisp)
  (require 'init-haskell)
  (require 'init-sh)
  ;; ...
#+end_src

While this might sound stupid to manually load files that has clear naming
pattern, I still like to do it manually, because it helps byte compiler, it has
less footprint on runtime performance, the list is not big and I rarely add new
files. Another option would be to generate this list during 'compilation', but
again, I would love to avoid any unnecessary complications.

*** Loading =custom-file=

And the last thing to do is to load =custom-file=:

#+begin_src emacs-lisp
  ;; I don't use `customize' interface, but .dir-locals.el put 'safe'
  ;; variables into `custom-file'. And to be honest, I hate to allow
  ;; them every time I restart Emacs.
  (when (file-exists-p custom-file)
    (load custom-file nil 'nomessage))
#+end_src

** Content of =init-elpa=

Part of our bootstrap process is setting up package management and package
configuration tools, which is performed in =init-elpa= file.

*** Bootstrap =straight.el=

The bootstrap process of [[https://github.com/raxod502/straight][raxod502/straight]] is quire simple and well documented
in the official repository. Additionally, we want to avoid any modification
checks at startup by setting the value of =straight-check-for-modifications= to
=nil=, so everything runs faster. Also we want to install packages by default in
=use-package= forms. And then everything is straight-forward.

#+begin_src emacs-lisp
  (require 'config-path)

  (setq-default
   straight-repository-branch "develop"
   straight-check-for-modifications nil
   straight-use-package-by-default t
   straight-base-dir path-packages-dir)

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el"
                           path-packages-dir))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           (concat "https://raw.githubusercontent.com/"
                   "raxod502/straight.el/"
                   "develop/install.el")
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

The only bit I am not describing here (and I will do it in separate blog post)
is how I configure retries for networking operations.

*** Setup =use-package=

Now it's easy to setup =use-package=:

#+begin_src emacs-lisp
  (setq-default
   use-package-enable-imenu-support t)
  (straight-use-package 'use-package)
#+end_src

*** Popular packages

There are packages (or rather libraries) that should be loaded eagerly because
they are used extensively and they do not provide autoloads.

#+begin_src emacs-lisp
  (use-package s)
  (use-package dash)
#+end_src

** Content of Eldev

Eldev file defines our project.

*** Specify project files

#+begin_src emacs-lisp
  (setf eldev-project-main-file "init.el"
        eldev-main-fileset '("init.el"
                             "early-init.el"
                             "lisp/*.el"))

  ;; Emacs doesn't allow to add directory containing init.el to load
  ;; path, so we have to put other Emacs Lisp files in directory. Help
  ;; Eldev commands to locate them.
  (eldev-add-loading-roots 'build "lisp")
  (eldev-add-loading-roots 'bootstrap "lisp")
#+end_src

*** Use MELPA

*** Define bootstrap command

*** Define upgrade command

*** Define autoloads plugin

*** Linting configuration

** Content of Makefile

#+begin_src makefile
  .PHONY: clean
  clean:
    eldev clean all

  .PHONY: bootstrap
  bootstrap:
    eldev clean autoloads
    eldev -C --unstable -a -dtT build :autoloads

  .PHONY: upgrade
  upgrade:
    eldev -C --unstable -a -dtT upgrade

  .PHONY: compile
  compile:
    eldev clean elc
    eldev -C --unstable -a -dtT compile

  .PHONY: lint
  lint:
    eldev -C --unstable -a -dtT lint

  .PHONY: test
  test:
    eldev exec t
    eldev -C --unstable -a -dtT test

  .PHONY: roam
  roam:
    eldev exec "(progn (run-hooks 'after-init-hook) (vulpea-db-build))"
#+end_src

** autoloads

** Linting

** Testing

** eru

* Build tool

* Package management tool

* Package configuration tool

Do not use =:ensure t=.

* Linter

* Testing framework

* What's next

* Things to cover :noexport:

- choice of the tools
  - eldev vs cask vs makemsh
  - straight vs quelpa (package.el)
  - use-package vs leaf vs manual deferred loading
- naming convention
- bootstrap process
- configuring eldev
- autoloads
- tests
- eru (or other custom script to glue)
- advantages and disadvantages
- extending this monster further
